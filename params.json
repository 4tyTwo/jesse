{"name":"Jesse","tagline":"jesse (JSon Schema Erlang) is an implementation of a json schema validator for Erlang.","body":"=====\r\njesse [![Build Status](https://secure.travis-ci.org/klarna/jesse.png)](http://travis-ci.org/klarna/jesse)\r\n=====\r\n\r\njesse (JSon Schema Erlang) is an implementation of a json schema validator\r\nfor Erlang.\r\n\r\njesse implements [Draft 03] (http://tools.ietf.org/html/draft-zyp-json-schema-03) of\r\nthe specification. It supports almost all core schema definitions except:\r\n\r\n* format\r\n* $ref\r\n\r\nQuick start\r\n-----------\r\n\r\nThere are two ways of using jesse:\r\n\r\n* to use jesse internal in-memory storage to keep all your schema definitions\r\n  In this case jesse will look up a schema definition in its own storage,\r\n  and then validate given json.\r\n* it is also possible to provide jesse with schema definitions when jesse is called.\r\n\r\nExamples\r\n--------\r\n\r\n    NOTE: jesse doesn't have any parsing functionality. It currently works with three\r\n          formats: mochijson2, jiffy and jsx, so json needs to be parsed in advance,\r\n          or you can specify a callback which jesse will use to parse json.\r\n\r\n          In examples below and in jesse test suite jiffy parser is used.\r\n\r\n* Use jesse's internal in-memory storage:\r\n\r\n(parse json in advance)\r\n\r\n```erlang\r\n1> Schema = jiffy:decode(<<\"{\\\"items\\\": {\\\"type\\\": \\\"integer\\\"}}\">>).\r\n{[{<<\"items\">>,{[{<<\"type\">>,<<\"integer\">>}]}}]}\r\n2> jesse:add_schema(some_key, Schema).\r\nok\r\n3> Json1 = jiffy:decode(<<\"[1, 2, 3]\">>).\r\n[1,2,3]\r\n4> jesse:validate(some_key, Json1).\r\n{ok,[1,2,3]}\r\n5> Json2 = jiffy:decode(<<\"[1, \\\"x\\\"]\">>).\r\n[1,<<\"x\">>]\r\n6> jesse:validate(some_key, Json2).\r\n{error,{data_invalid,<<\"x\">>,not_integer,\r\n                     {[{<<\"type\">>,<<\"integer\">>}]}}}\"]\")\r\n```\r\n\r\n(using a callback)\r\n\r\n```erlang\r\n1> jesse:add_schema(some_key,\r\n1>                  <<\"{\\\"uniqueItems\\\": true}\">>,\r\n1>                  fun jiffy:decode/1).\r\nok\r\n2> jesse:validate(some_key,\r\n2>                <<\"[1, 2]\">>,\r\n2>                fun jiffy:decode/1).\r\n{ok,[1,2]}\r\n3> jesse:validate(some_key,\r\n3>                <<\"[{\\\"foo\\\": \\\"bar\\\"}, {\\\"foo\\\": \\\"bar\\\"}] \">>,\r\n3>                fun jiffy:decode/1).\r\n{error,{data_invalid,[{[{<<\"foo\">>,<<\"bar\">>}]},\r\n                      {[{<<\"foo\">>,<<\"bar\">>}]}],\r\n                     {{[{<<\"foo\">>,<<\"bar\">>}]},not_unique},\r\n                     {uniqueItems,true}}}\r\n```\r\n\r\n* Call jesse with schema definition in place (do not use internal storage)\r\n\r\n(parse json in advance)\r\n\r\n```erlang\r\n1> Schema = jiffy:decode(<<\"{\\\"pattern\\\": \\\"^a*$\\\"}\">>).\r\n{[{<<\"pattern\">>,<<\"^a*$\">>}]}\r\n2> Json1 = jiffy:decode(<<\"\\\"aaa\\\"\">>).\r\n<<\"aaa\">>\r\n3> jesse:validate_with_schema(Schema, Json1).\r\n{ok,<<\"aaa\">>}\r\n4> Json2 = jiffy:decode(<<\"\\\"abc\\\"\">>).\r\n<<\"abc\">>\r\n5> jesse:validate_with_schema(Schema, Json2).\r\n{error,{data_invalid,<<\"abc\">>,no_match,<<\"^a*$\">>}}\r\n```\r\n\r\n(using a callback)\r\n\r\n```erlang\r\n1> Schema = <<\"{\\\"patternProperties\\\": {\\\"f.*o\\\": {\\\"type\\\": \\\"integer\\\"}}}\">>.\r\n<<\"{\\\"patternProperties\\\": {\\\"f.*o\\\": {\\\"type\\\": \\\"integer\\\"}}}\">>\r\n2> jesse:validate_with_schema(Schema,\r\n2>                            <<\"{\\\"foo\\\": 1, \\\"foooooo\\\" : 2}\">>,\r\n2>                            fun jiffy:decode/1).\r\n{ok,{[{<<\"foo\">>,1},{<<\"foooooo\">>,2}]}}\r\n3> jesse:validate_with_schema(Schema,\r\n3>                            <<\"{\\\"foo\\\": \\\"bar\\\", \\\"fooooo\\\": 2}\">>,\r\n3>                            fun jiffy:decode/1).\r\n{error,{data_invalid,<<\"bar\">>,not_integer,\r\n                     {[{<<\"type\">>,<<\"integer\">>}]}}}\"\"}]\"\"}\")\r\n```\r\n\r\nCaveats\r\n-------\r\n* pattern and patternProperty attributes:\r\n\r\n  jesse uses standard erlang module `re` for regexp matching, therefore there could be\r\n  some incompatible regular expressions in schemas you define.\r\n\r\n  From erlang docs: \"re's matching algorithms are currently based on the PCRE library,\r\n  but not all of the PCRE library is interfaced\"\r\n\r\n  But most of common cases should work fine.\r\n\r\nContributing\r\n------------\r\n\r\nIf you see something missing or incorrect, a pull request is most welcome!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}